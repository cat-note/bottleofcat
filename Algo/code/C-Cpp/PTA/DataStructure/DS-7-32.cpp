#include <cstdio>
#include <vector>

using namespace std;

// è¿™é¢˜ç›´æ¥è®©äººæƒ³èµ·äº†QQçš„â€œä¸€ç¬”ç”»â€çº¢åŒ…ï¼Œå…¶å®å°±æ˜¯æ¬§æ‹‰å›¾é—®é¢˜
// ä¸è¿‡ä¸€ç¬”ç”»çº¢åŒ…æ„æˆçš„æ˜¯æ¬§æ‹‰é€šè·¯ï¼Œæ•´ä½“æ¥è¯´æ˜¯åŠæ¬§æ‹‰å›¾(å¹¶æ²¡æœ‰å›åˆ°èµ·ç‚¹)
// æœ¬é¢˜éœ€è¦èƒ½ä¸€ç¬”å›åˆ°èµ·ç‚¹ï¼Œå› æ­¤è¦åˆ¤æ–­æ˜¯å¦æœ‰ã€æ¬§æ‹‰å›è·¯ã€‘

// å¹¶æŸ¥é›†ï¼Œç”¨äºåˆ¤æ–­è¿é€šæ€§
class UnionFind
{
private:
    int size; // èŠ‚ç‚¹æ•°é‡
    vector<int> parents;
    vector<int> counts; // è®°å½•æ ‘ä¸­èŠ‚ç‚¹æ•°é‡
public:
    UnionFind(int size)
    {
        this->size = size;
        parents.resize(size);
        counts.resize(size, 1); // åˆå§‹æ¯ä¸ªèŠ‚ç‚¹è‡ªèº«æ„æˆä¸€ä¸ªé›†åˆ
        for (int i = 0; i < size; i++)
            parents[i] = i; // å¹¶æŸ¥é›†ä¸­å„èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹åˆå§‹ä¸ºè‡ªå·±
    }
    // å¯»æ‰¾èŠ‚ç‚¹æ‰€åœ¨æ ‘çš„æ ¹ç»“ç‚¹, é¡ºå¸¦è·¯å¾„å‹ç¼©
    int find(int index)
    {
        return parents[index] == index ? index : parents[index] = find(parents[index]);
    }
    // å¹¶æ“ä½œï¼Œå°†å°æ ‘å¹¶å…¥å¤§æ ‘
    void merge(int node1, int node2)
    {
        int root1 = find(node1); // å¯»æ‰¾èŠ‚ç‚¹1æ‰€åœ¨çš„æ ‘çš„æ ¹
        int root2 = find(node2); // å¯»æ‰¾èŠ‚ç‚¹2æ‰€åœ¨çš„æ ‘çš„æ ¹
        if (root1 == root2)      // æ ‘æ ¹ç›¸åŒä¸è¿›è¡Œåˆå¹¶æ“ä½œ-----------ğŸ’¡å®¹æ˜“å†™æ‰
            return;
        // å°æ ‘å¹¶å…¥å¤§æ ‘
        if (counts[root1] > counts[root2])
        {
            parents[root2] = root1;
            counts[root1] += parents[root2];
        }
        else
        {
            parents[root1] = root2;
            counts[root2] += parents[root1];
        }
    }
};

int main()
{
    int nodeNum, edgeNum; // èŠ‚ç‚¹æ•°å’Œè¾¹æ•°
    scanf("%d %d", &nodeNum, &edgeNum);
    UnionFind uf(nodeNum);           // åˆå§‹åŒ–å¹¶æŸ¥é›†
    vector<int> degrees(nodeNum, 0); // å‚¨å­˜æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æ•°
    // è¯»å…¥æ‰€æœ‰è¾¹
    for (int i = 0; i < edgeNum; i++)
    {
        int node1, node2;
        scanf("%d %d", &node1, &node2);
        node1--; // é¢˜ç›®ä¸­æ˜¯1~Nç¼–å·ï¼Œè¿™é‡Œå¤„ç†ç”¨0~N-1ç¼–å·
        node2--;
        uf.merge(node1, node2); // è¿›è¡Œå¹¶æ“ä½œ
        degrees[node1]++;       // åº¦å¢åŠ 
        degrees[node2]++;
    }
    int output = 1; // è¾“å‡ºæ˜¯å¦æ˜¯æ¬§æ‹‰å›¾
    for (int i = 0; i < nodeNum; i++)
    {
        // æ¬§æ‹‰å›¾åˆ¤å®šæ¡ä»¶1: æ‰€æœ‰é¡¶ç‚¹çš†è¿é€š
        // æ¬§æ‹‰å›¾åˆ¤å®šæ¡ä»¶2: æ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°ä¸ºå¶æ•°
        // å¦‚æœä¸æ˜¯æ‰€æœ‰é¡¶ç‚¹éƒ½åœ¨åŒä¸€é›†åˆä¸­ï¼Œå°±æ˜¯ä¸è¿é€šçš„
        // å¦‚æœæœ‰å¥‡æ•°åº¦æ•°å‡ºç°ï¼Œä¹Ÿæ˜¯ä¸æ»¡è¶³æ¬§æ‹‰å›¾çš„
        if (uf.find(0) != uf.find(i) || (degrees[i] & 1))
        {
            output = 0;
            break;
        }
    }
    printf("%d", output);
    return 0;
}

/*
    è¿™é¢˜ä¸»è¦è€ƒå¯Ÿäº†å¯¹äºã€ä¸€ä¸ªå›¾æ˜¯å¦æ˜¯æ¬§æ‹‰å›¾ã€‘çš„åˆ¤æ–­ã€‚

    æ¬§æ‹‰å›¾æ˜¯å…·æœ‰ã€æ¬§æ‹‰å›è·¯ã€‘çš„å›¾ï¼Œè€Œæ¬§æ‹‰å›è·¯æŒ‡çš„æ˜¯ã€ä»ä»»ä¸€ä¸ªé¡¶ç‚¹å‡ºå‘ï¼Œèƒ½æœ‰ä¸”ä»…æœ‰ç»è¿‡å›¾ä¸­æ¯æ¡è¾¹ä¸€æ¬¡ï¼Œæœ€åå›åˆ°è¿™ä¸ªç‚¹ã€‘çš„å›è·¯ã€‚

    å¯»æ‰¾æ¬§æ‹‰å›è·¯çš„ç®—æ³•ä¸€çœ¼çœ‹ä¸Šå»å‘ç°: æˆ‘è¶…ï¼å¥½éš¾ï¼
    ç„¶è€Œæœ¬é¢˜åªéœ€è¦åˆ¤æ–­ã€æ— å‘å›¾ä¸­æœ‰æ²¡æœ‰æ¬§æ‹‰å›è·¯ã€‘ï¼Œå› æ­¤æŠŠæ¡ä»¥ä¸‹ä¸¤ä¸ªåˆ¤æ–­æŒ‡æ ‡å°±è¡Œ:

        1. æ— å‘å›¾ä¸­ã€æ‰€æœ‰ã€‘é¡¶ç‚¹ã€æ˜¯è¿é€šçš„ã€‘ã€‚
            - é‡‡ç”¨ã€å¹¶æŸ¥é›†ã€‘å¯ä»¥é«˜æ•ˆåˆ¤æ–­ã€‚

        2. æ— å‘å›¾ä¸­æ¯ä¸ªé¡¶ç‚¹çš„ã€åº¦æ•°ã€‘æ˜¯ã€å¶æ•°ã€‘ã€‚

    æ»¡è¶³ä¸Šé¢ä¸¤ç‚¹çš„è¯ï¼Œæ— å‘å›¾ä¸­å°±æœ‰æ¬§æ‹‰å›è·¯ã€‚

        - SomeBottle 2023.1.24
*/